<!DOCTYPE html>
<html>
<head>
    <title>FTC PIDF Motor Control Simulator</title>
    <style>
        body { font-family: sans-serif; }
        .controls { display: flex; gap: 15px; flex-wrap: wrap; }
        .control-group { border: 1px solid #ccc; padding: 10px; border-radius: 5px; }
        .control-group.control-button { border: none; }
        .control-group h3 { margin: 0 0 10px 0; }
        label { display: block; margin-bottom: 5px; }
        input[type="number"] { width: 70px; }
        button { padding: 8px 16px; }
        #plot { width: 100%; height: 400px; margin-top: 10px; } 
        .hidden { display: none; }
    </style>
    <script src="https://cdn.plot.ly/plotly-3.1.1.min.js"></script>
</head>
<body>
    <h1>FTC PIDF Motor Control Simulator</h1>

    <div class="controls">
        <div class="control-group">
            <h3>Velocity PIDF</h3>
            <label>P: <input type="number" id="p" value="18" step="0.1"></label>
            <label>I: <input type="number" id="i" value="0" step="0.1"></label>
            <label>D: <input type="number" id="d" value="0" step="0.1"></label>
            <label>F: <input type="number" id="f" value="10" step="0.1"></label>
            <h3>Position P</h3>
            <label>P: <input type="number" id="pp" value="10" step="0.1"></label>
        </div>

        <div class="control-group">
            <h3>Physical</h3>
            <label>Motor Inertia kg-m2: <input type="number" id="motorInertia" value="0.00022" step="0.00001"></label>
            <!-- 0.01 is recommended by one estimatee, 0.001 by another -->
            <label>Load Inertia kg-m2: <input type="number" id="loadInertia" value="0.001" step="0.0001"></label>
            <!-- torque constant is the stall torque divided by the stall current -->
            <label title="stall torque divided by the stall current">Torque Const N-m/A: <input type="number" id="torqueConst" value="0.0117" step="0.0001"></label>
            <label>Back-EMF RPM-V: <input type="number" id="backEmf" value="224" step="0.1"></label>
            <label>Max Ticks/sec: <input type="number" id="maxTicksPerSec" value="2800" step="100"></label>
            <label>Static Friction: <input type="number" id="staticFriction" value="0.2" step="0.01"></label>
            <label>Coulomb Friction: <input type="number" id="couloumbFriction" value="0.1" step="0.01"></label>
            <label>Viscous Friction: <input type="number" id="viscousFriction" value="0.005" step="0.0001"></label>
        </div>

        <div class="control-group">
            <h3>Control</h3>
            <label>Mode:
                <select id="mode">
                    <option value="encoder">Run with Encoder</option>
                    <option value="position">Run to Position</option>
                    <option value="without">Run without Encoder</option>
                </select>
            </label>
            <label>Target: <input type="number" id="target" value="1.0" step="0.1"></label>
            <label>Position: <input type="number" id="ptarget" value="2000" step="1"></label>
            <label>Duration (s): <input type="number" id="duration" value="3" step="0.1"></label>
        </div>
        <div class="control-group control-button">
            <div>
                <button onclick="simulate()">Run Simulation</button>
            </div>
            <div>
                <table id="velocitysettle" class="hidden">
                    <tr><th>Velocity</th><th>Settle</th></tr>
                    <tr><td>0.1%</td><td></td></tr>
                    <tr><td>0.2%</td><td></td></tr>
                    <tr><td>0.5%</td><td></td></tr>
                    <tr><td>1.0%</td><td></td></tr>
                    <tr><td>2.0%</td><td></td></tr>
                    <tr><td>5.0%</td><td></td></tr>
                    <tr><td>10.0%</td><td></td></tr>
                    <tr><td>20.0%</td><td></td></tr>
                    <tr><td>50.0%</td><td></td></tr>
                </table>
                <table id="positionsettle" class="hidden">
                    <tr><th>Position</th><th>Settle</th></tr>
                    <tr><td>0</td><td></td></tr>
                    <tr><td>1</td><td></td></tr>
                    <tr><td>2</td><td></td></tr>
                    <tr><td>5</td><td></td></tr>
                    <tr><td>10</td><td></td></tr>
                    <tr><td>20</td><td></td></tr>
                    <tr><td>50</td><td></td></tr>
                    <tr><td>100</td><td></td></tr>
                    <tr><td>200</td><td></td></tr>
                </table>
            </div>
        </div>
    </div>
    <div id="plot">
    </div>
    <script>
class Motor {
    constructor(motorInertia, loadIntertia, torqueConst, backEmf, maxTicksPerSec, staticFriction, couloumbFriction, viscousFriction) {
        this.motorInertia = motorInertia;
        this.loadIntertia = loadIntertia;
        this.torqueConst = torqueConst;
        this.backEmf = backEmf;
        this.maxTicksPerSec = maxTicksPerSec;
        this.staticFriction = staticFriction;
        this.couloumbFriction = couloumbFriction;
        this.viscousFriction = viscousFriction;
        this.speedFactor = 0.8;
        this.maxControlOutput = 32767;
        this.maxVoltage = 12;
        this.lastTorque = 0;
        this.torqueElecConstant = 0.00015 / 2.18;  // 150 uH / ohm
        this.reset();
    }

    reset() {
        this.velocity = 0; // ticks per second
        this.position = 0; // ticks
        this.acceleration = 0;
    }

    update(controlOutput, dt) {
        // Convert control output to "force" that drives velocity
        const normalizedControl = controlOutput / this.maxControlOutput;
        const maxVel = this.maxTicksPerSec * this.speedFactor;

        let motorTorque = this.torqueConst * normalizedControl * this.maxTicksPerSec;
        motorTorque -= this.backEmf / this.maxVoltage * this.velocity / maxVel;
        // simple inductence delay;
        const alpha = dt / (this.torqueElecConstant + dt);
        motorTorque = motorTorque * alpha + this.lastTorque * (1 - alpha);
        this.lastTorque = motorTorque;
        // dodgy constants
        let frictionTorque = 0;
        if (Math.abs(this.velocity) < 20) {
            frictionTorque = Math.min(this.staticFriction, Math.abs(motorTorque)) * Math.sign(motorTorque);
        } else {
            frictionTorque = this.couloumbFriction * Math.sign(motorTorque) + this.viscousFriction * this.velocity / maxVel * (6000 / 60 * 3.14159 * 2 * this.speedFactor);
        }
        this.acceleration = (motorTorque - frictionTorque) / (this.motorInertia + this.loadIntertia);

        this.velocity += this.acceleration * dt;
        this.position += this.velocity * dt;

        // Velocity limiting (motor can't exceed physical limits)
        this.velocity = Math.max(-this.maxTicksPerSec, Math.min(this.maxTicksPerSec, this.velocity));
    }
}

class PIDFController {
    constructor(p, i, d, f) {
        this.kp = p; this.ki = i; this.kd = d; this.kf = f;
        this.reset();
    }

    reset() {
        this.integral = 0;
        this.lastError = 0;
    }

    compute(error, feedforward, dt) {
        this.integral += error * dt;

        // Integral windup protection
        const maxIntegral = 32767;
        this.integral = Math.max(-maxIntegral, Math.min(maxIntegral, this.integral));

        const derivative = dt > 0 ? (error - this.lastError) / dt : 0;
        this.lastError = error;

        return this.kp * error + this.ki * this.integral + this.kd * derivative + this.kf * feedforward;
    }
}

function simulate() {
    const p = +document.getElementById('p').value;
    const i = +document.getElementById('i').value;
    const d = +document.getElementById('d').value;
    const f = +document.getElementById('f').value;
    const pp = +document.getElementById('pp').value;
    const motorInertia = +document.getElementById('motorInertia').value;
    const loadIntertia = +document.getElementById('loadInertia').value;
    const torqueConst = +document.getElementById('torqueConst').value;
    const backEmf = +document.getElementById('backEmf').value;
    const maxTicksPerSec = +document.getElementById('maxTicksPerSec').value;
    const staticFriction = +document.getElementById('staticFriction').value;
    const couloumbFriction = +document.getElementById('couloumbFriction').value;
    const viscousFriction = +document.getElementById('viscousFriction').value;
    const mode = document.getElementById('mode').value;
    const etarget = +document.getElementById('target').value;
    const ptarget = +document.getElementById('ptarget').value;
    const duration = +document.getElementById('duration').value;

    const motor = new Motor(motorInertia, loadIntertia, torqueConst, backEmf, maxTicksPerSec, staticFriction, couloumbFriction, viscousFriction);
    const controller = new PIDFController(p, i, d, f);

    const controlDt = 0.05; // 20Hz control updates
    const simDt = 0.001; // 1ms simulation timestep
    const steps = Math.floor(duration / simDt);
    const data = [];

    let lastControlTime = 0;
    let controlOutput = 0;
    let nextControlOutput = 0;
    let targetValue = 0;
    let actualValue = 0;

    for (let step = 0; step < steps; step++) {
        let target = etarget;
        const time = step * simDt;

        if (mode === 'without') {
            targetValue = target * motor.maxTicksPerSec;
        } else {
            targetValue = target * motor.maxTicksPerSec * motor.speedFactor;
        }
        actualValue = motor.velocity;
        const dataEntry = {
            time: time,
            target: targetValue,
            actual: actualValue,
            position: motor.position
        };
        if (mode === 'position') {
            const perror = ptarget - Math.floor(motor.position);
            let pspeed = perror * Math.max(pp, 1) / motor.maxTicksPerSec;
            target = Math.max(-target, Math.min(target, pspeed));
            dataEntry.targetPosition = ptarget;
            dataEntry.target = target;
            targetValue = target * motor.maxTicksPerSec * motor.speedFactor;
        }
        // Update control at 20Hz
        if (time - lastControlTime >= controlDt) {
            if (mode === 'without') {
                nextControlOutput = Math.round(motor.maxControlOutput * target);
            } else {
                const error = (Math.floor(targetValue / 20) - Math.floor(actualValue / 20)) * 20;

                // Feedforward: target power -> control output
                const feedforward = target * motor.maxTicksPerSec * motor.speedFactor;
                nextControlOutput = controller.compute(error, feedforward, controlDt);
                nextControlOutput = Math.floor(Math.max(-motor.maxControlOutput, Math.min(motor.maxControlOutput, nextControlOutput)));
            }
            lastControlTime = time;
        }
        /* controller delay */
        if (time - lastControlTime >= controlDt * 0.05) {
            controlOutput = nextControlOutput;
        }

        // Always update motor physics
        motor.update(controlOutput, simDt);
        dataEntry.output = nextControlOutput;
        data.push(dataEntry);
    }
    plotResults(data);
}

function plotResults(data) {
    const t = data.map(d => d.time);
    const traces = [
        {x: t, y: data.map(d => d.output/32767), name: 'Control', line: {color: 'green'}, yaxis: 'y3'},
        {x: t, y: data.map(d => d.actual), name: 'velocity', line: {color: 'blue'}},
        {x: t, y: data.map(d => d.target), name: 'target V', line: {color: 'blue', dash: 'dash'}},
        {x: t, y: data.map(d => d.position), name: 'position', line: {color: 'red'}, yaxis: 'y2'}
    ];
    const position = (data[0]?.targetPosition !== undefined);
    if (position) {
        traces.push({x: t, y: data.map(d => d.targetPosition), name: 'target P', line: {color: 'red', dash: 'dash'}, yaxis: 'y2'});
    }
    Plotly.newPlot('plot', traces, {
        margin: {l: 0, r: 0, t: 0, b: 0},
        xaxis: {title: {text: 'Time (s)'}, automargin: true},
        yaxis: {title: {text: 'ticks/s'}, rangemode: 'tozero', showgrid: false, automargin: true},
        yaxis2: {title: {text: 'ticks'}, rangemode: 'tozero', overlaying: 'y', side: 'right', showgrid: false, automargin: true},
        yaxis3: {range: [-1, 1], overlaying: 'y', showticklabels: false, showgrid: false, zerolinecolor: '#ddd'},
        font: {family: 'sans-serif'}
    });
    const v = document.getElementById('velocitysettle');
    const p = document.getElementById('positionsettle');
    v.classList.toggle('hidden', position);
    p.classList.toggle('hidden', !position);
    [...(position ? p : v).rows].slice(1).forEach(r => {
        const val = parseFloat(r.cells[0].textContent);
        let dur = 0;
        data.forEach(d => {
            if (position && Math.abs(d.position - d.targetPosition) > val) {
                dur = d.time;
            }
            if (!position && Math.abs(d.actual / d.target - 1) * 100 > val) {
                dur = d.time;
            }
        });
        if (dur == data[data.length - 1].time) {
            r.cells[1].textContent = ''
        } else{
            r.cells[1].textContent = dur.toFixed(3) + 's';
        }
    });
}


setTimeout(simulate, 1);
    </script>
</body>
</html>
