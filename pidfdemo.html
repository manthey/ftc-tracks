<!DOCTYPE html>
<html>
<head>
    <title>FTC PIDF Motor Control Simulator</title>
    <style>
        body { font-family: sans-serif; }
        .controls { display: flex; gap: 15px; flex-wrap: wrap; }
        .control-group { border: 1px solid #ccc; padding: 10px; border-radius: 5px; }
        .control-group.control-button { border: none; }
        .control-group h3 { margin: 0 0 10px 0; }
        label { display: block; margin-bottom: 5px; }
        input[inputmode="decimal"] { width: 80px; }
        button { padding: 8px 16px; }
        #plot { width: 100%; height: 400px; margin-top: 10px; } 
        .hidden { display: none; }
    </style>
    <script src="https://cdn.plot.ly/plotly-3.1.1.min.js"></script>
</head>
<body>
    <h1>FTC PIDF Motor Control Simulator</h1>

    <div class="controls">
        <div class="control-group">
            <h3>Velocity PIDF</h3>
            <label>P: <input type="text" inputmode="decimal" id="p" value="10" step="0.1"></label>
            <label>I: <input type="text" inputmode="decimal" id="i" value="3" step="0.1"></label>
            <label>D: <input type="text" inputmode="decimal" id="d" value="0" step="0.1"></label>
            <label>F: <input type="text" inputmode="decimal" id="f" value="5" step="0.1"></label>
            <h3>Position P</h3>
            <label>P: <input type="text" inputmode="decimal" id="pp" value="10" step="0.1"></label>
            <h3>Internal</h3>
            <label>Speed Fraction: <input type="text" inputmode="decimal" id="speedFraction" value="0.85" step="0.01"></label>
            <h3>Physical</h3>
            <label title="Rev gear ratios are 84/29 (2.897), 76/21 (3.619), 68/13 (5.230)">Gear Ratio: <input type="text" inputmode="decimal" id="gearRatio" value="1" step="0.1"></label>
            <label title="After gearing -- use gear ratio of 1 if this is the reflected load inertia">Load Inertia: <input type="text" inputmode="decimal" id="loadInertia" value="0.00003" step="0.00001"> kg-m2</label>
        </div>

        <div class="control-group">
            <h3>Motor</h3>
            <label>Motor Inertia: <input type="text" inputmode="decimal" id="motorInertia" value="0.0000022" step="0.0000001"> kg-m2</label>
            <label>Stall Torque: <input type="text" inputmode="decimal" id="stallTorque" value="0.105" step="0.0001"> N-m</label>
            <label>Stall Current: <input type="text" inputmode="decimal" id="stallCurrent" value="8.5" step="0.1"> A</label>
            <label>No-Load Current: <input type="text" inputmode="decimal" id="noLoadCurrent" value="0.4" step="0.1"> A</label>
            <label>Free Speed: <input type="text" inputmode="decimal" id="freeSpeed" value="6000" step="0.1"> RPM</label>
            <label>Max Ticks/sec: <input type="text" inputmode="decimal" id="maxTicksPerSec" value="2800" step="100"></label>
            <label>Static Friction: <input type="text" inputmode="decimal" id="staticFriction" value="0.01" step="0.001"> N-m</label>
            <label>Coulomb Friction: <input type="text" inputmode="decimal" id="coulombFriction" value="0.0015" step="0.0001"> N-m</label>
            <label>Viscous Friction: <input type="text" inputmode="decimal" id="viscousFriction" value="0.000005" step="0.00000001"> N-m-s/rad</label>
            <label>Supply Voltage: <input type="text" inputmode="decimal" id="supplyVoltage" value="12" step="0.1"> V</label>
            <label title="For one motor, this is around 0.06 ohms; for multiple motors, multiply it by the number of motors operating together">Supply Resistance: <input type="text" inputmode="decimal" id="supplyResistance" value="0.06" step="0.01"> &#x3A9;</label>
        </div>

        <div class="control-group">
            <h3>Control</h3>
            <label>Mode:
                <select id="mode">
                    <option value="encoder">Run with Encoder</option>
                    <option value="position">Run to Position</option>
                    <option value="without">Run without Encoder</option>
                </select>
            </label>
            <label>Zero Power:
                <select id="zeroPower">
                    <option value="brake">Brake</option>
                    <option value="float">Float</option>
                </select>
            </label>
            <label>Start: <input type="text" inputmode="decimal" id="start" value="0.0" step="0.1"></label>
            <label>Target: <input type="text" inputmode="decimal" id="target" value="1.0" step="0.1"></label>
            <label>Position: <input type="text" inputmode="decimal" id="ptarget" value="2000" step="1"> ticks</label>
            <label>Duration: <input type="text" inputmode="decimal" id="duration" value="3" step="0.1"> s</label>
        </div>
        <div class="control-group control-button">
            <div>
                <button onclick="simulate()">Run Simulation</button>
            </div>
            <div>
                <table id="velocitysettle" class="hidden">
                    <tr><th>Velocity</th><th>Settle</th></tr>
                    <tr><td>0.1%</td><td></td></tr>
                    <tr><td>0.2%</td><td></td></tr>
                    <tr><td>0.5%</td><td></td></tr>
                    <tr><td>1.0%</td><td></td></tr>
                    <tr><td>2.0%</td><td></td></tr>
                    <tr><td>5.0%</td><td></td></tr>
                    <tr><td>10.0%</td><td></td></tr>
                    <tr><td>20.0%</td><td></td></tr>
                    <tr><td>50.0%</td><td></td></tr>
                </table>
                <table id="positionsettle" class="hidden">
                    <tr><th>Position</th><th>Settle</th></tr>
                    <tr><td>0</td><td></td></tr>
                    <tr><td>1</td><td></td></tr>
                    <tr><td>2</td><td></td></tr>
                    <tr><td>5</td><td></td></tr>
                    <tr><td>10</td><td></td></tr>
                    <tr><td>20</td><td></td></tr>
                    <tr><td>50</td><td></td></tr>
                    <tr><td>100</td><td></td></tr>
                    <tr><td>200</td><td></td></tr>
                </table>
            </div>
        </div>
    </div>
    <div id="plot">
    </div>
    <script>
class Motor {
    constructor(values) {
        this.motorInertia = values.motorInertia;
        this.loadInertia = values.loadInertia / values.gearRatio / values.gearRatio;
        this.stallCurrent = values.stallCurrent;
        this.noLoadCurrent = values.noLoadCurrent;
        this.stallTorque = values.stallTorque;
        this.freeSpeed = values.freeSpeed;
        this.maxTicksPerSec = values.maxTicksPerSec;
        this.staticFriction = values.staticFriction;
        this.coulombFriction = values.coulombFriction;
        this.viscousFriction = values.viscousFriction;
        this.speedFraction = values.speedFraction;
        this.supplyVoltage = values.supplyVoltage;
        this.supplyResistance = values.supplyResistance;
        this.zeroPower = values.zeroPower;
        this.maxControlOutput = 32767;
        this.lastTorque = 0;
        this.torqueElecConstant = 0.00015 / 2.18;  // 150 uH / ohm
        this.reset();
    }

    reset() {
        this.velocity = 0; // ticks per second
        this.position = 0; // ticks
        this.acceleration = 0;
    }

    update(controlOutput, dt) {
        // normalizedControl and normalizedVelocity are in the range of [-1, 1]
        let normalizedControl = controlOutput / this.maxControlOutput;
        let normalizedVelocity =  this.velocity / this.maxTicksPerSec; 
        let velRadPerSec = normalizedVelocity * (this.freeSpeed / 60 * Math.PI * 2);

        // this is velRadPerSec * Ke / supplyVoltage, since 
        // Ke = supplyVoltage / (this.freeSpeed / 60 * Math.PI * 2)
        let backEMF = normalizedVelocity;
        if (normalizedControl === 0 && this.zeroPower === 'float') {
            backEMF = 0;
        }
        // handle battery sag
        let drawCurrent = this.stallCurrent * (Math.abs(normalizedControl) - Math.abs(backEMF));
        normalizedControl *= (this.supplyVoltage - drawCurrent * this.supplyResistance) / this.supplyVoltage;
        // calculate torque
        let motorTorque = this.stallTorque * (normalizedControl - backEMF); 
        // simple inductance delay;
        const alpha = dt / (this.torqueElecConstant + dt);
        if (this.lastTorque !== undefined) {
            motorTorque = motorTorque * alpha + this.lastTorque * (1 - alpha);
        }
        this.lastTorque = motorTorque;
        let frictionTorque = 0;

        /* Approximate slowing
        if (Math.abs(this.velocity) < this.maxTicksPerSec * 0.001) {
            if (Math.abs(motorTorque) < this.staticFriction) {
                this.velocity = 0;
                frictionTorque = motorTorque;
            } else {
                frictionTorque = Math.min(this.staticFriction, Math.abs(motorTorque)) * Math.sign(motorTorque);
            }
        } else {
            frictionTorque = this.coulombFriction * Math.sign(this.velocity) + this.viscousFriction * velRadPerSec;
        }
		*/

        // aproximate stribeck effect at slow speeds
        const vStribeckNorm = 0.001;  
        const vAbsNorm = Math.abs(normalizedVelocity);
        const dryFrictionMag = this.staticFriction * Math.exp(-Math.pow(vAbsNorm / vStribeckNorm, 2)) + this.coulombFriction * (1 - Math.exp(-Math.pow(vAbsNorm / vStribeckNorm, 2)));
                            
        frictionTorque = dryFrictionMag * Math.sign(this.velocity) + this.viscousFriction * velRadPerSec;
        const blendStatic = Math.exp(-Math.pow(vAbsNorm / vStribeckNorm, 2)); 

        const staticMag = this.staticFriction * blendStatic;
        const staticTorque = Math.sign(motorTorque) * Math.min(staticMag, Math.abs(motorTorque));
        frictionTorque = frictionTorque * (1 - blendStatic) + staticTorque * blendStatic;

        const accelerationRadPerSec2 = (motorTorque - frictionTorque) / (this.motorInertia + this.loadInertia);
        this.acceleration = accelerationRadPerSec2 * (this.maxTicksPerSec / (this.freeSpeed / 60 * Math.PI * 2));
        this.velocity += this.acceleration * dt;
        this.position += this.velocity * dt;

        this.velocity = Math.max(-this.maxTicksPerSec, Math.min(this.maxTicksPerSec, this.velocity));
        if (Math.abs(this.velocity) < 0.05) {
            this.velocity = 0;
        }
    }
}

class PIDFController {
    constructor(p, i, d, f) {
        this.kp = p; this.ki = i; this.kd = d; this.kf = f;
        this.reset();
    }

    reset() {
        this.integral = 0;
        this.lastDerivative = 0;
        this.lastError = 0; 
    }

    compute(error, feedforward, dt) {
        this.integral += error * dt;

        // Integral windup protection
        const maxIntegral = 2800;
        this.integral = Math.max(-maxIntegral, Math.min(maxIntegral, this.integral));
        console.log(this.integral); // DWM::
        const derivative = dt > 0 && this.lastError !== undefined ? (error - this.lastError) / dt : 0;
        const deriv = derivative * 0.4 + this.lastDerivative * 0.6;
        this.lastDerivative = derivative;
        this.lastError = error;

        // console.log(this.kp, error, this.ki, this.integral, this.kd, derivative, this.kf, feedforward, dt, this.kp * error + this.ki * this.integral + this.kd * derivative + this.kf * feedforward);
        let control = this.kp * error + this.ki * this.integral + this.kd * deriv + this.kf * feedforward;

        return control
    }
}

function updateURL(query) {
    const url = new URL(window.location);
    const params = new URLSearchParams();
    Object.keys(query).forEach(key => {
        params.set(key, query[key]);
    });
    const newURL = params.toString() ? `${url.pathname}?${params.toString()}` : url.pathname;
    window.history.pushState({}, '', newURL);
}

function simulate() {
    const v = {};
    const query = {};
    document.querySelectorAll('input[inputmode="decimal"][id]').forEach((input) => {
        v[input.id] = +input.value;
        if (input.value !== input.getAttribute('value') && input.value.trim()) {
            query[input.id] = input.value.trim();
        }            
    });
    document.querySelectorAll('select[id]').forEach((input) => {
        v[input.id] = input.value;
        const defaultOption = input.querySelector('option[selected]');
        const defaultValue = defaultOption ? defaultOption.value : input.options[0]?.value;
        if (input.value !== defaultValue) {
            query[input.id] = input.value;
        }
    });
    updateURL(query);

    const motor = new Motor(v);
    motor.velocity = v.start * motor.maxTicksPerSec * motor.speedFraction;
    motor.lastTorque = undefined;
    const controller = new PIDFController(v.p, v.i, v.d, v.f);

    const controlDt = 0.05; // 20Hz control updates
    const simDt = 0.001; // 1ms simulation timestep
    const steps = Math.floor(v.duration / simDt);
    const data = [];

    let lastControlTime = 0;
    let controlOutput = Math.floor(Math.max(-motor.maxControlOutput, Math.min(motor.maxControlOutput, v.start * motor.maxControlOutput * motor.speedFraction)));
    let nextControlOutput = controlOutput;
    let targetValue = 0;
    let actualValue = 0;

    for (let step = 0; step < steps; step++) {
        let target = v.target;
        const time = step * simDt;

        if (v.mode === 'without' || (target === 0 && motor.zeroPower === 'float')) {
            targetValue = target * motor.maxTicksPerSec;
        } else {
            targetValue = target * motor.maxTicksPerSec * motor.speedFraction;
        }
        actualValue = motor.velocity;
        const dataEntry = {
            time: time,
            target: targetValue,
            actual: actualValue,
            position: motor.position
        };
        if (v.mode === 'position') {
            const perror = v.ptarget - Math.floor(motor.position);
            let pspeed = perror * Math.max(v.pp, 1) / motor.maxTicksPerSec;
            target = Math.max(-target, Math.min(target, pspeed));
            dataEntry.targetPosition = v.ptarget;
            dataEntry.target = target;
            targetValue = target * motor.maxTicksPerSec * motor.speedFraction;
        }
        // Update control at 20Hz
        if (time - lastControlTime >= controlDt) {
            if (v.mode === 'without') {
                nextControlOutput = Math.round(motor.maxControlOutput * target);
            } else {
                const intVelocity = (Math.floor(motor.position) - (motor.lastIntPosition || 0));
                motor.lastIntPosition = Math.floor(motor.position);
                const error = (Math.floor(targetValue / 20) - intVelocity) * 20;
                // Feedforward: target power -> control output
                const feedforward = target * motor.maxTicksPerSec * motor.speedFraction;
                nextControlOutput = controller.compute(error, feedforward, controlDt);
                nextControlOutput = Math.floor(Math.max(-motor.maxControlOutput, Math.min(motor.maxControlOutput, nextControlOutput)));
            }
            lastControlTime = time;
        }
        /* controller delay */
        if (time - lastControlTime >= controlDt * 0.05) {
            controlOutput = nextControlOutput;
        }

        // Always update motor physics
        motor.update(controlOutput, simDt);
        dataEntry.output = nextControlOutput;
        data.push(dataEntry);
    }
    plotResults(data, motor);
}

function plotResults(data, motor) {
    const t = data.map(d => d.time);
    const traces = [
        {x: t, y: data.map(d => d.output/32767), name: 'Control', line: {color: 'green'}, yaxis: 'y3'},
        {x: t, y: data.map(d => d.actual), name: 'velocity', line: {color: 'blue'}},
        {x: t, y: data.map(d => d.target), name: 'target V', line: {color: 'blue', dash: 'dash'}},
        {x: t, y: data.map(d => d.position), name: 'position', line: {color: 'red'}, yaxis: 'y2'}
    ];
    const position = (data[0]?.targetPosition !== undefined);
    if (position) {
        traces.push({x: t, y: data.map(d => d.targetPosition), name: 'target P', line: {color: 'red', dash: 'dash'}, yaxis: 'y2'});
    }
    Plotly.newPlot('plot', traces, {
        margin: {l: 0, r: 0, t: 0, b: 0},
        xaxis: {title: {text: 'Time (s)'}, automargin: true},
        yaxis: {title: {text: 'ticks/s'}, rangemode: 'tozero', showgrid: false, automargin: true},
        yaxis2: {title: {text: 'ticks'}, rangemode: 'tozero', overlaying: 'y', side: 'right', showgrid: false, automargin: true},
        yaxis3: {range: [-1, 1], overlaying: 'y', showticklabels: false, showgrid: false, zerolinecolor: '#ddd'},
        font: {family: 'sans-serif'}
    });
    const v = document.getElementById('velocitysettle');
    const p = document.getElementById('positionsettle');
    v.classList.toggle('hidden', position);
    p.classList.toggle('hidden', !position);
    [...(position ? p : v).rows].slice(1).forEach(r => {
        const val = parseFloat(r.cells[0].textContent);
        let dur = 0;
        data.forEach(d => {
            if (position && Math.abs(d.position - d.targetPosition) > val) {
                dur = d.time;
            }
            if (!position && Math.abs(d.actual - d.target) * 100 / motor.maxTicksPerSec / motor.speedFraction > val) {
                dur = d.time;
            }
        });
        if (dur == data[data.length - 1].time) {
            r.cells[1].textContent = ''
        } else{
            r.cells[1].textContent = dur.toFixed(3) + 's';
        }
    });
}

document.querySelectorAll('input, textarea').forEach(input => {
	input.addEventListener('keydown', function(e) {
		if (e.key === 'Enter') {
			e.preventDefault();
			simulate();
		}
	});
});

const params = new URLSearchParams(window.location.search);
params.forEach((value, id) => {
    const input = document.getElementById(id);
    if (input && value.trim()) {
        input.value = value.trim();
    }
});

setTimeout(simulate, 1);
    </script>
</body>
</html>
